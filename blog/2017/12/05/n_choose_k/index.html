<!DOCTYPE HTML>
<html lang='en'>
<head>
<meta charset="utf-8">
<link rel="stylesheet" href="/style.css">
<link href='https://fonts.googleapis.com/css?family=Merriweather+Sans:400,400italic,700,700italic' rel='stylesheet' type='text/css'>
<link href='https://fonts.googleapis.com/css?family=Oranienbaum' rel='stylesheet' type='text/css'>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<!--Load the AJAX API-->
<script type="text/javascript" src="https://www.google.com/jsapi"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-47801434-1', 'chogg.name');
  ga('send', 'pageview');
</script>
<meta content='nanoc 4.8.10' name='generator'>
<title>
Compile-time combinatorics
[Charles R. Hogg III]
</title>
</head>
<body>
<div id='title'>
<a title="Main page" href="/">Charles R. Hogg III</a>
<div id='nav'>
<ul>
<li>
<a title="About the author, the website, etc." href="/about/">About</a>
</li>
<li>
<a title="Personal blog" href="/blog/">Blog</a>
</li>
<li>
<a title="Things I'm working on" href="/projects/">Projects</a>
</li>
<li>
<a title="Ways to contact me online" href="/contact/">Contact</a>
</li>
</ul>
</div>
</div>
<hr>
<div id='main'>
<div id='post'>
<h1>
Compile-time combinatorics
</h1>
<aside class='posted_at'>
Posted at 2017-12-05 20:18
</aside>
<aside class='tldr'>
<b>tl;dr:</b>
Writing poker software gave me an excuse to try out template metaprogramming.  Figuring out how to actually <b>use</b> the results was a fun challenge, so I'm posting my strategy here for anyone else who might find it useful.
</aside>
<article>
<p>Compile-time computation has obvious appeal: any work you do when you <em>build</em> the program is already done when you <em>run</em> it -- hence, faster programs.</p>
<p>This sounds great in theory, but a problem soon arises in practice. Most of the things you want to compute, you won't know until you run the program. (That's why we <em>have</em> programs, instead of just recording the final answer: we want to be able to deal with a wide variety of inputs, on demand.)</p>
<p>That's what this post is about: bridging the gap between what we <em>can</em> know when we <em>build</em> the program, and what we <em>need</em> to know when we <em>run</em> the program.</p>
<p>I won't bury the lede; here is the basic strategy:</p>
<ol style="list-style-type: decimal">
<li>Compute all values we could possibly need, up to some maximum.</li>
<li>Store the results in specific memory locations when we <em>build</em> the program.</li>
<li>Access these memory locations when we <em>run</em> the program.</li>
</ol>
<p>There are a few twists. We'll use <code>constexpr</code> for the functions that tell us where to store and find the values: this lets us call the exact <em>same</em> functions when we build and run the program, and also lets us write tests for them. We'll also protect our users from the gory details by exposing only a polished, lightweight, usable class, which communicates its limitations in a natural way.</p>
<h3 id="the-problem-of-interest">The problem of interest</h3>
<p>So, what are we actually computing?</p>
<p>Well, I'm writing poker software. I very often need to know how many ways I can choose a certain number of objects out of a larger collection. For example: how many poker hands are there? As many as there are ways to choose 5 cards out of a 52 card deck. This is "52 choose 5", usually written <span class="math inline">\(\binom{52}{5}\)</span>, and it's the kind of quantity we want to compute.</p>
<p>A couple of properties make this a nice application for some compile-time programming.</p>
<ul>
<li>First, we know the maximum when we build the program: we'll never be choosing from more than 52 things. As I said, compile-time computation needs to know a maximum number ahead of time, and it's very appealing that our limit is a natural feature of the problem we're solving, and not artificial.</li>
<li>Second, it's a 2-dimensional example (how many total things, and how many things we choose). Almost every other example uses either factorials or Fibonacci numbers, which are 1-dimensional. It's obvious how to lay those out in memory; the two-dimensional example adds a pleasing wrinkle to the problem.</li>
</ul>
<p>So, this is the problem at hand: compute all combinatorics results for up to 52 items at compile time, and make them conveniently available at runtime.</p>
<p>The post is rather long, as it's meant as a complete guide for readers looking to do their own compile-time computation (including code samples, and my commentary on the design decisions). Less ambitious readers might rather skim than read in depth. That said, some aspects that may appeal to the template-averse crowd include:</p>
<ul>
<li>my utter delight at rediscovering the simple elegance of the formula for computing combinatorics (so simple, a child could understand it!);</li>
<li>a surprisingly concise, fast, and accurate square-root function;</li>
<li>and, the final API we expose to the users -- I hope it communicates its abilities and limitations in a natural way.</li>
</ul>
<p>Let's begin.</p>
<h2 id="computations-for-specific-values-of-n-and-k">Computations for specific values of <span class="math inline">\(N\)</span> and <span class="math inline">\(K\)</span>
</h2>
<p>We'll start with the core code -- the part which does the actual computations.</p>
<pre><code class="language-cpp"><span class="c1">// The recurrence relation (see Pascal's Triangle).</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">N</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">K</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nl">Choose</span> <span class="p">:</span> <span class="n">std</span><span class="o">::</span><span class="n">integral_constant</span><span class="o">&lt;</span><span class="kt">uint64_t</span><span class="p">,</span>
                                       <span class="n">Choose</span><span class="o">&lt;</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">K</span> <span class="o">-</span> <span class="mi">1</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">+</span>
                                           <span class="n">Choose</span><span class="o">&lt;</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">K</span><span class="o">&gt;::</span><span class="n">value</span><span class="o">&gt;</span>
<span class="p">{</span>
  <span class="k">static_assert</span><span class="p">(</span><span class="n">K</span> <span class="o">&lt;=</span> <span class="n">N</span><span class="p">,</span> <span class="s">"Cannot choose more than N items"</span><span class="p">);</span>
<span class="p">};</span></code></pre>
<p>(The <code>static_assert</code> is there for good hygiene: now, nonsense values won't even <em>attempt</em> to compile.)</p>
<p>This recurrence relation lets us build more complicated answers out of simpler ones. Let's pause and take a moment to appreciate just how simple, transparent, and elegant it is.</p>
<p>We want to know how many ways we can choose <span class="math inline">\(k\)</span> items from <span class="math inline">\(n\)</span>, written as <span class="math inline">\(\binom{n}{k}\)</span>. Let's imagine we already crunched all the numbers for fewer than <span class="math inline">\(n\)</span> items. Well, every subset of <span class="math inline">\(k\)</span> items from <span class="math inline">\(n\)</span> will either include that new <span class="math inline">\(n\)</span>th item, or it won't.</p>
<ul>
<li>If the subset <strong>does</strong> include it, then there are <span class="math inline">\((k-1)\)</span> items left to choose from the original <span class="math inline">\((n-1)\)</span>; this is just <span class="math inline">\(\binom{n-1}{k-1}\)</span>.</li>
<li>If the subset <strong>doesn't</strong> include it, then we have to choose all <span class="math inline">\(k\)</span> items from the previous <span class="math inline">\((n-1)\)</span>; this is <span class="math inline">\(\binom{n-1}{k}\)</span>.</li>
</ul>
<p>Since these groups can't overlap, we simply add these two counts to get the total, and the famous equation falls right out:</p>
<p><span class="math display">\[\binom{n}{k} = \binom{n-1}{k-1} + \binom{n-1}{k}.\]</span></p>
<p>That's the <em>mathematical</em> elegance here. The <em>computational</em> elegance is that we get the benefits of <a href="https://medium.freecodecamp.org/demystifying-dynamic-programming-3efafb8d4296">dynamic programming</a> for free. In other words, the compiler computes every <span class="math inline">\((n,k)\)</span> pair only once, and automatically reuses the answer after that (because it is encoded in a <em>type</em>, and each type is defined only once). This is a very good thing, since otherwise, the time to compute each number would be proportional to the number itself. <span class="math inline">\(\binom{n}{k}\)</span> gets pretty big, pretty fast. If we let <span class="math inline">\(n\)</span> go up to only, say, 52 (since there are 52 cards in the deck), there are some individual answers which would take half a <em>quadrillion</em> steps to compute!</p>
<p>So, we have a computationally efficient implementation of a mathematically elegant relationship. That's great, but so far, it won't actually compute anything. We've defined our computation in terms of simpler values, but we've never said what those simpler values <em>are</em>. We need a base case -- or rather, two.</p>
<pre><code class="language-cpp"><span class="c1">// Base case for when we choose all the items.</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">Choose</span><span class="o">&lt;</span><span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">integral_constant</span><span class="o">&lt;</span><span class="kt">uint64_t</span><span class="p">,</span> <span class="mi">1u</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="p">};</span>

<span class="c1">// Base case for when we choose none of the items.</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">Choose</span><span class="o">&lt;</span><span class="n">N</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;</span> <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">integral_constant</span><span class="o">&lt;</span><span class="kt">uint64_t</span><span class="p">,</span> <span class="mi">1u</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="p">};</span></code></pre>
<p>The base cases for <span class="math inline">\(n\)</span>-choose-<span class="math inline">\(k\)</span> occur when we choose all of the items, or none of them. In either case, the answer is 1: there is exactly one way to do that.</p>
<p>This is now good enough to actually start computing some values. If we write, say, <code>Choose&lt;52, 5&gt;</code>, the compiler will replace it with <code>2598960</code> everywhere in our program, just as if we'd hardcoded the constant. In fact, it's good enough to compute <em>almost all</em> the values, with one exception.</p>
<p>Consider <span class="math inline">\(\binom{0}{0}\)</span>: the number of ways to choose 0 items out of 0. Yes, it is well-defined; it happens to be 1, as we might have guessed from either of the rules above. But the compiler can't figure out <em>which</em> of these rules to use (even though they both happen to give the same answer). We have to tell it explicitly:</p>
<pre><code class="language-cpp"><span class="c1">// Base case for when there are no items.</span>
<span class="k">template</span> <span class="o">&lt;&gt;</span>
<span class="k">struct</span> <span class="n">Choose</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;</span> <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">integral_constant</span><span class="o">&lt;</span><span class="kt">uint64_t</span><span class="p">,</span> <span class="mi">1u</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="p">};</span></code></pre>
<p>You could be forgiven for wondering whether we really need this special case at all: when in our code are we ever going to compute <span class="math inline">\(\binom{0}{0}\)</span>? Spoiler alert: we won't, but if we eliminate this bit of code, we'll need to add ugly, hacky special cases for the rest of the code we'll still need to write. It's simpler just to cover all the cases now.</p>
<h2 id="how-do-we-use-it">How do we <em>use</em> it?</h2>
<p>There's a problem here.</p>
<p>We can compute any values we want for <span class="math inline">\(\binom{n}{k}\)</span> at compile time -- that is, at the time the program gets <strong>built</strong>. But we won't know which values we actually <em>want</em> to compute until the program gets <strong>run</strong>! In other words, we can handle something like <code>Choose&lt;52, 5&gt;</code>, no sweat. But if we have <em>variables</em> <span class="math inline">\(n = 52\)</span> and <span class="math inline">\(k = 5\)</span> when our program's running, we <em>can't</em> compute <code>Choose&lt;n, k&gt;</code>, because everything inside the <code>&lt;...&gt;</code> has to finish <em>before</em> the program gets run.</p>
<p>Here's a two-step strategy to make this actually useful:</p>
<ol style="list-style-type: decimal">
<li>Decide ahead of time which values we could possibly need;</li>
<li>Figure out how to store them so we can actually get them when we run the program.</li>
</ol>
<p>The first step is easy. This program is always choosing cards, and there are 52 of them. If we store all the values for every <span class="math inline">\(n\)</span> and <span class="math inline">\(k\)</span> up to <span class="math inline">\(n = 52\)</span>, we'll be all set. This works out to 1431 different values: not remotely taxing.</p>
<p>For the second step, a simple array seems natural. It's not totally trivial, because we'll need a two-way mapping.</p>
<ul>
<li>For any given slot index <span class="math inline">\(i\)</span>, which <span class="math inline">\((n, k)\)</span> pair is stored there? (We'll use this when we <strong>write</strong> the answers.)</li>
<li>For each <span class="math inline">\((n,k)\)</span> pair, which of the 1431 slots <span class="math inline">\(i\)</span> should we store its value in? (We'll use this when we <strong>read</strong> the answers.)</li>
</ul>
<h3 id="index-math">Index math</h3>
<p>I decided to use the most natural mapping: first do <span class="math inline">\(\binom{0}{0}\)</span>, then both of the <span class="math inline">\(\binom{1}{k}\)</span>, then all 3 of the <span class="math inline">\(\binom{2}{k}\)</span>, etc. We see the pattern here: the first index for a given <span class="math inline">\(n\)</span> is just <span class="math inline">\((1 + 2 + ... + n) = n(n+1)/2\)</span>. After that, we just need to add <span class="math inline">\(k\)</span>:</p>
<pre><code class="language-cpp"><span class="k">constexpr</span> <span class="kt">size_t</span> <span class="nf">index</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">n</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">n</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">k</span><span class="p">;</span> <span class="p">}</span></code></pre>
<p>Inverting these mappings is reasonably straightforward. We notice that <code>index()</code> is quadratic in <span class="math inline">\(n\)</span>, so we can solve for it using the quadratic formula. Then once we have <span class="math inline">\(n\)</span>, we know <span class="math inline">\(k\)</span> is just how far we are past the first index for that <span class="math inline">\(n\)</span>:</p>
<p><span class="math display">\[
\begin{align}
n(i) &amp;= \left\lfloor \frac{\sqrt{1 + 8i} - 1}{2} \right\rfloor \\
k(i) &amp;= i - \mathtt{index}(n(i), 0)
\end{align}
\]</span></p>
<p>Here, we hit a <em>slight</em> detour. It turns out that we can't use C++'s standard <code>sqrt()</code> function at compile time, <a href="https://stackoverflow.com/a/17348030/1523582">because of its side effects</a>. We'll have to roll our own! Fortunately, <a href="https://stackoverflow.com/a/34134071/1523582">this isn't too hard</a>:</p>
<pre><code class="language-cpp"><span class="k">constexpr</span> <span class="kt">double</span> <span class="nf">sqrt_newton_raphson</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="kt">double</span> <span class="n">curr</span><span class="p">,</span> <span class="kt">double</span> <span class="n">prev</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">curr</span> <span class="o">==</span> <span class="n">prev</span><span class="p">)</span> <span class="o">?</span> <span class="nl">curr</span>
                        <span class="p">:</span> <span class="n">sqrt_newton_raphson</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">curr</span> <span class="o">+</span> <span class="n">x</span> <span class="o">/</span> <span class="n">curr</span><span class="p">),</span> <span class="n">curr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">constexpr</span> <span class="kt">double</span> <span class="nf">sqrt</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="mf">0.</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">())</span>
             <span class="o">?</span> <span class="n">sqrt_newton_raphson</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="mf">0.</span><span class="p">)</span>
             <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">quiet_NaN</span><span class="p">();</span>
<span class="p">}</span></code></pre>
<p>Such a neat algorithm! Not only is it fast, accurate, and easy to understand, but it's also one of the few instances where comparing floating point numbers for <em>exact</em> equality actually makes sense (as opposed to being a huge mistake, a bug waiting to happen).</p>
<p>My favourite aspect of this function is how transparent the logic is. Forget the calculus used to derive it, and just look at what it's actually doing. We have a guess for the square root; call our current guess <code>curr</code>. If <code>curr</code> were the <em>true</em> square root, then dividing our number by <code>curr</code> would give us <code>curr</code> again. Instead, it gives us another number, which is too high when <code>curr</code> is too low, and vice versa. The square root must be in-between these two numbers; so, we take their <em>average</em> as our next guess.</p>
<p>With a compiler-compatible <code>sqrt()</code> in our toolbox, we can close the loop on our index functions:</p>
<pre><code class="language-cpp"><span class="k">constexpr</span> <span class="kt">size_t</span> <span class="nf">n</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">((</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">8</span> <span class="o">*</span> <span class="n">i</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">constexpr</span> <span class="kt">size_t</span> <span class="nf">k</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">i</span> <span class="o">-</span> <span class="n">index</span><span class="p">(</span><span class="n">n</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span> <span class="p">}</span></code></pre>
<p>Pro tip: this is a <em>great</em> opportunity to add a few unit tests to check the round-trip identity (i.e., making sure that <span class="math inline">\(\mathtt{index}(n(i), k(i)) = i\)</span>).</p>
<h3 id="building-an-array">Building an array</h3>
<p>This is the bridge between compile-time and runtime, the way our precomputed values can actually get used. We need a function which takes in a bunch of indices, and returns the <span class="math inline">\(\binom{n}{k}\)</span>-values corresponding to those indices, in an array.</p>
<pre><code class="language-cpp"><span class="c1">// Compile-time populated array with the first consecutive values of N-choose-K</span>
<span class="c1">// (as enumerated in the natural ordering).</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span><span class="p">...</span> <span class="n">Is</span><span class="o">&gt;</span>
<span class="k">constexpr</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">uint64_t</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">...(</span><span class="n">Is</span><span class="p">)</span><span class="o">&gt;</span>
<span class="n">choose_values</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">index_sequence</span><span class="o">&lt;</span><span class="n">Is</span><span class="p">...</span><span class="o">&gt;</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">uint64_t</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">...(</span><span class="n">Is</span><span class="p">)</span><span class="o">&gt;</span><span class="p">({</span><span class="n">Choose</span><span class="o">&lt;</span><span class="n">n</span><span class="p">(</span><span class="n">Is</span><span class="p">),</span> <span class="n">k</span><span class="p">(</span><span class="n">Is</span><span class="p">)</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">...});</span>
<span class="p">}</span></code></pre>
<p>We're using <em>variadic templates</em> -- that is, templates that accept an arbitrary number of parameters. I had always shied away from learning how to use these, as the syntax looked strange and forbidding to me. But working through a simple example like this helped me see they're actually pretty straightforward. We get an index sequence (whose size and contents are known at compile time), and we build an array of the same size, turning each index into the corresponding <span class="math inline">\(\binom{n}{k}\)</span> value.</p>
<p>With this in hand, all that's left is to pass the <em>right</em> indices.</p>
<h3 id="getting-the-first-m-indices">Getting the "first <span class="math inline">\(m\)</span> indices"</h3>
<p>We're going to want all the indices from <span class="math inline">\(0\)</span> up to <span class="math inline">\(m(n_\text{max})\)</span>, where <span class="math inline">\(m\)</span> is some function that tells us how many values there are up to <span class="math inline">\(n_\text{max}\)</span>. It's pretty straightforward to deduce from the pattern of the first few values:</p>
<pre><code class="language-cpp"><span class="c1">// Compute the number of N-choose-K values with N at most some maximum value.</span>
<span class="k">constexpr</span> <span class="kt">size_t</span> <span class="nf">num_values_up_to</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="p">}.</span></code></pre>
<p>Now we have all we need to create our final array:</p>
<pre><code class="language-cpp"><span class="c1">// Compile-time populated array with all n-choose-k up to some maximum n.</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">N_max</span><span class="o">&gt;</span>
<span class="k">constexpr</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">uint64_t</span><span class="p">,</span> <span class="n">num_values_up_to</span><span class="p">(</span><span class="n">N_max</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">choose_values_up_to</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">choose_values</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_index_sequence</span><span class="o">&lt;</span><span class="n">num_values_up_to</span><span class="p">(</span><span class="n">N_max</span><span class="p">)</span><span class="o">&gt;</span><span class="p">());</span>
<span class="p">}</span></code></pre>
<h2 id="polish-and-usability">Polish and usability</h2>
<p>Calling a function that returns a 1431-valued array is not a very appealing interface, even if all the values were computed at compile time! It would be better to create the array once, at the beginning of the program, and make it easy to access. At the same time, we want to be careful to avoid messy global variables.</p>
<p>A good solution is a well-named templated class, which stores the (<code>const</code>!) array as a <code>private static</code> member variable. The <code>static</code> means that all members share the same copy of the array, and the <code>private</code> means nobody will be able to mess with it. We can make instances of this class without having to think too hard about it, confident that they'll be as small as possible.</p>
<p>Assuming all the messy details above are hidden inside of an <code>internal</code> namespace, this would look something like the following.</p>
<pre><code class="language-cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">N_max</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">CappedCombinator</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="kt">uint64_t</span> <span class="n">choose</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">n</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">k</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="n">N_max</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">k</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">cached_values_</span><span class="p">[</span><span class="n">internal</span><span class="o">::</span><span class="n">index</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">)];</span>
  <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
  <span class="k">const</span> <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">uint64_t</span><span class="p">,</span> <span class="n">internal</span><span class="o">::</span><span class="n">num_values_up_to</span><span class="p">(</span><span class="n">N_max</span><span class="p">)</span><span class="o">&gt;</span>
    <span class="n">cached_values_</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">N_max</span><span class="o">&gt;</span>
<span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">uint64_t</span><span class="p">,</span> <span class="n">internal</span><span class="o">::</span><span class="n">num_values_up_to</span><span class="p">(</span><span class="n">N_max</span><span class="p">)</span><span class="o">&gt;</span>
    <span class="n">CappedCombinator</span><span class="o">&lt;</span><span class="n">N_max</span><span class="o">&gt;::</span><span class="n">cached_values_</span> <span class="o">=</span>
      <span class="n">internal</span><span class="o">::</span><span class="n">choose_values_up_to</span><span class="o">&lt;</span><span class="n">N_max</span><span class="o">&gt;</span><span class="p">();</span></code></pre>
<p>The <code>assert()</code>s here are worth commenting on. Some folks <a href="https://www.softwariness.com/articles/assertions-in-cpp/">feel that they should never be used</a>. I don't agree -- I think this is a proper use of <code>assert()</code>. It guards against programming errors only, not user input (since this class should never take user input directly). And, given that the whole point of this is to make combinatorics as fast as possible, I <em>want</em> the compiler to remove these statements completely when I turn off debug mode.</p>
<p>I plan on building separate debug and production versions of my program; <code>assert()</code> is perfect for this.</p>
<h2 id="using-the-api">Using the API</h2>
<p>The real test of what I've built: how usable is it? How does it look at the call site? Is it easy to use correctly, and hard to use incorrectly? Let's take a look at some example code.</p>
<pre><code class="language-cpp"><span class="n">CappedCombinator</span><span class="o">&lt;</span><span class="n">cards</span><span class="o">::</span><span class="n">DECK_SIZE</span><span class="o">&gt;</span> <span class="n">combinator</span><span class="p">;</span>

<span class="c1">// A number which uniquely identifies this poker hand.</span>
<span class="kt">size_t</span> <span class="n">hand_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="kt">size_t</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">size_t</span> <span class="n">hand_cards_left</span> <span class="o">=</span> <span class="n">hand</span><span class="p">.</span><span class="n">card_indices</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
<span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="kt">size_t</span> <span class="nl">index</span> <span class="p">:</span> <span class="n">hand</span><span class="p">.</span><span class="n">card_indices</span><span class="p">)</span> <span class="c1">// Assume the indices are sorted.</span>
<span class="p">{</span>
  <span class="n">hand_index</span> <span class="o">+=</span> <span class="p">(</span>
    <span class="n">combinator</span><span class="p">.</span><span class="n">choose</span><span class="p">(</span><span class="n">cards</span><span class="o">::</span><span class="n">DECK_SIZE</span> <span class="o">-</span> <span class="n">start</span><span class="p">,</span> <span class="n">hand_cards_left</span><span class="p">)</span> <span class="o">-</span>
    <span class="n">combinator</span><span class="p">.</span><span class="n">choose</span><span class="p">(</span><span class="n">cards</span><span class="o">::</span><span class="n">DECK_SIZE</span> <span class="o">-</span> <span class="n">index</span><span class="p">,</span> <span class="n">hand_cards_left</span><span class="p">));</span>
  <span class="n">start</span> <span class="o">=</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
  <span class="o">--</span><span class="n">hand_cards_left</span><span class="p">;</span>
<span class="p">}</span></code></pre>
<p>Don't worry too much about the details of what the code is doing, or why we want to do it. The point is that it shows how easy it is to take the numbers we computed at compile time, and use them to compute meaningful quantities with arbitrary values at runtime. The limitations of the class (i.e., don't pass anything higher than <code>DECK_SIZE</code>) are clearly communicated when we declare the variable. And the only way we can violate those limitations is via a programming bug, not bad user input (assuming that <code>hand.card_indices</code> is generated by some other part of the program, and not <em>directly</em> by the user).</p>
<p>All in all, my first adventure in figuring out how to useful work at compile time turned out pretty satisfyingly.</p>

</article>
</div>

</div>
<div id='source'>
<a href='https://github.com/chiphogg/chogg_name/tree/master/content/blog/compile-time-combinatorics.pandoc'>
Page source on GitHub
</a>
</div>
</body>
</html>
